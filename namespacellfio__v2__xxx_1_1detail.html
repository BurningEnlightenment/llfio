<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLFIO: llfio_v2_xxx::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLFIO
   &#160;<span id="projectnumber">v2.00 late beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacellfio__v2__xxx_1_1detail.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">llfio_v2_xxx::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Obtain a handle to the path <b>currently</b> containing this handle's file entry.  
<a href="namespacellfio__v2__xxx_1_1detail.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>attach_or_reinterpret</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_acceptable</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_acceptable&lt; llfio_v2_xxx::byte &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_chartype_acceptable</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_chartype_acceptable&lt; char &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_chartype_acceptable&lt; char16_t &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_chartype_acceptable&lt; char8_t &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_chartype_acceptable&lt; wchar_t &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>listening_tls_socket_handle_deleter</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>path_view_component_operator_slash_visitor</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>path_view_iterator</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>string_view_printer</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>thread_local_log_level_filter</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>tls_socket_handle_deleter</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>tls_socket_source_deleter</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>value_pointer_fascade</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae8e18c4998e0aa92b606b3b88eec04a5"><td class="memItemLeft" align="right" valign="top"><a id="ae8e18c4998e0aa92b606b3b88eec04a5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>char16_t</b> : unsigned short </td></tr>
<tr class="separator:ae8e18c4998e0aa92b606b3b88eec04a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a02c02d05e24d34c25324c192df11c0b4"><td class="memItemLeft" align="right" valign="top"><a id="a02c02d05e24d34c25324c192df11c0b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LLFIO_TEMPLATE</b> (class T, class U) LLFIO_TREQUIRES(LLFIO_TPRED(std</td></tr>
<tr class="separator:a02c02d05e24d34c25324c192df11c0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c52ccdc38be135a374dbb4a7d1d466"><td class="memItemLeft" align="right" valign="top"><a id="a77c52ccdc38be135a374dbb4a7d1d466"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LLFIO_TEMPLATE</b> (class T) LLFIO_TREQUIRES(LLFIO_TPRED(std</td></tr>
<tr class="separator:a77c52ccdc38be135a374dbb4a7d1d466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e7d3f24db89f80ccebc240106110c0"><td class="memItemLeft" align="right" valign="top"><a id="a88e7d3f24db89f80ccebc240106110c0"></a>
global_dynamic_thread_pool_impl &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>global_dynamic_thread_pool</b> () noexcept</td></tr>
<tr class="separator:a88e7d3f24db89f80ccebc240106110c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5764bb77ec58ac60c6b92958a16043"><td class="memItemLeft" align="right" valign="top"><a id="a1f5764bb77ec58ac60c6b92958a16043"></a>
result&lt; <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>containing_directory</b> (optional&lt; std::reference_wrapper&lt; filesystem::path &gt;&gt; out_filename, const <a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> &amp;h, const <a class="el" href="classfs__handle.html">fs_handle</a> &amp;fsh, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d) noexcept</td></tr>
<tr class="separator:a1f5764bb77ec58ac60c6b92958a16043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286da8606a5eb74cf26dcc9838c49ae8"><td class="memTemplParams" colspan="2"><a id="a286da8606a5eb74cf26dcc9838c49ae8"></a>
template&lt;class Dest , class Src &gt; </td></tr>
<tr class="memitem:a286da8606a5eb74cf26dcc9838c49ae8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fill_failure_info</b> (Dest &amp;dest, const Src &amp;src)</td></tr>
<tr class="separator:a286da8606a5eb74cf26dcc9838c49ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a6e1add1783bc959c4954ac92300f8"><td class="memTemplParams" colspan="2"><a id="a72a6e1add1783bc959c4954ac92300f8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a72a6e1add1783bc959c4954ac92300f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log_inst_to_info</b> (const <a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> *inst, const char *buffer)</td></tr>
<tr class="separator:a72a6e1add1783bc959c4954ac92300f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a53f79b32d63da588eb41da9fc9b78b"><td class="memItemLeft" align="right" valign="top"><a id="a8a53f79b32d63da588eb41da9fc9b78b"></a>
char &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>thread_local_log_level</b> ()</td></tr>
<tr class="separator:a8a53f79b32d63da588eb41da9fc9b78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c231bfd6dbe08a75cc2837170699c6"><td class="memItemLeft" align="right" valign="top"><a id="af0c231bfd6dbe08a75cc2837170699c6"></a>
result&lt; byte_io_handle::registered_buffer_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>map_handle_allocate_registered_buffer</b> (size_t &amp;bytes) noexcept</td></tr>
<tr class="separator:af0c231bfd6dbe08a75cc2837170699c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa74d6fc6b9aef877233654f514041d"><td class="memItemLeft" align="right" valign="top"><a id="acaa74d6fc6b9aef877233654f514041d"></a>
result&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pagesize_from_flags</b> (section_handle::flag _flag) noexcept</td></tr>
<tr class="separator:acaa74d6fc6b9aef877233654f514041d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c9ba461630fe02b8c818df8b4f0402"><td class="memTemplParams" colspan="2"><a id="a24c9ba461630fe02b8c818df8b4f0402"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a24c9ba461630fe02b8c818df8b4f0402"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>constexpr_strlen</b> (const T *s) noexcept</td></tr>
<tr class="separator:a24c9ba461630fe02b8c818df8b4f0402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a020ef47a862a0d6ee2a8cb5b83000"><td class="memItemLeft" align="right" valign="top"><a id="af5a020ef47a862a0d6ee2a8cb5b83000"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>constexpr_strlen</b> (const byte *s) noexcept</td></tr>
<tr class="separator:af5a020ef47a862a0d6ee2a8cb5b83000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca839dcad90518be469393ff94a298c"><td class="memItemLeft" align="right" valign="top"><a id="aeca839dcad90518be469393ff94a298c"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, char *dest_buffer, size_t dest_buffer_length, const llfio_v2_xxx::byte *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:aeca839dcad90518be469393ff94a298c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cb1db78991ce362d7262bcf0e26921"><td class="memItemLeft" align="right" valign="top"><a id="ae7cb1db78991ce362d7262bcf0e26921"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, char *dest_buffer, size_t dest_buffer_length, const char *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:ae7cb1db78991ce362d7262bcf0e26921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa588880bc76221e6ec9715b70013105"><td class="memItemLeft" align="right" valign="top"><a id="afa588880bc76221e6ec9715b70013105"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, char *dest_buffer, size_t dest_buffer_length, const wchar_t *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:afa588880bc76221e6ec9715b70013105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f0c5568c83abca21bee9cd838f9542"><td class="memItemLeft" align="right" valign="top"><a id="ae7f0c5568c83abca21bee9cd838f9542"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, char *dest_buffer, size_t dest_buffer_length, const char8_t *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:ae7f0c5568c83abca21bee9cd838f9542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa126c294bd24c6170729c81a2d746cf7"><td class="memItemLeft" align="right" valign="top"><a id="aa126c294bd24c6170729c81a2d746cf7"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, char *dest_buffer, size_t dest_buffer_length, const char16_t *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:aa126c294bd24c6170729c81a2d746cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08446a93ea987bfbb45fd45f5fcd612"><td class="memItemLeft" align="right" valign="top"><a id="aa08446a93ea987bfbb45fd45f5fcd612"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, wchar_t *dest_buffer, size_t dest_buffer_length, const llfio_v2_xxx::byte *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:aa08446a93ea987bfbb45fd45f5fcd612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e8ca5dbdce64395344f278844f1f7c"><td class="memItemLeft" align="right" valign="top"><a id="a78e8ca5dbdce64395344f278844f1f7c"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, wchar_t *dest_buffer, size_t dest_buffer_length, const char *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:a78e8ca5dbdce64395344f278844f1f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bb62584e742b0b8397a63c333f7d59"><td class="memItemLeft" align="right" valign="top"><a id="a76bb62584e742b0b8397a63c333f7d59"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, wchar_t *dest_buffer, size_t dest_buffer_length, const wchar_t *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:a76bb62584e742b0b8397a63c333f7d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43d4352669c668ec5882e7d953b3ea6"><td class="memItemLeft" align="right" valign="top"><a id="aa43d4352669c668ec5882e7d953b3ea6"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, wchar_t *dest_buffer, size_t dest_buffer_length, const char8_t *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:aa43d4352669c668ec5882e7d953b3ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8e44c460932265c6c97b949eeaac92"><td class="memItemLeft" align="right" valign="top"><a id="aaf8e44c460932265c6c97b949eeaac92"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, wchar_t *dest_buffer, size_t dest_buffer_length, const char16_t *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:aaf8e44c460932265c6c97b949eeaac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7461933c74794f79178f952c42083ed"><td class="memTemplParams" colspan="2"><a id="aa7461933c74794f79178f952c42083ed"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa7461933c74794f79178f952c42083ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_deleter</b> (...)</td></tr>
<tr class="separator:aa7461933c74794f79178f952c42083ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253dd24caea0c8a34a5260f3acf0b8ca"><td class="memItemLeft" align="right" valign="top"><a id="a253dd24caea0c8a34a5260f3acf0b8ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LLFIO_TEMPLATE</b> (class U) LLFIO_TREQUIRES(LLFIO_TEXPR(std</td></tr>
<tr class="separator:a253dd24caea0c8a34a5260f3acf0b8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1081a69ba488868ed42e8c7ce5bb1e17"><td class="memItemLeft" align="right" valign="top"><a id="a1081a69ba488868ed42e8c7ce5bb1e17"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>is_allocator</b> (...)</td></tr>
<tr class="separator:a1081a69ba488868ed42e8c7ce5bb1e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7e4173df2abeba7daed38f11bffc09"><td class="memItemLeft" align="right" valign="top"><a id="a6c7e4173df2abeba7daed38f11bffc09"></a>
constexpr float&#160;</td><td class="memItemRight" valign="bottom"><b>constexpr_float_allbits_set_nan</b> ()</td></tr>
<tr class="separator:a6c7e4173df2abeba7daed38f11bffc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ed947b141d970bb7ff5c21a6881d51"><td class="memTemplParams" colspan="2"><a id="ad6ed947b141d970bb7ff5c21a6881d51"></a>
template&lt;class Src &gt; </td></tr>
<tr class="memitem:ad6ed947b141d970bb7ff5c21a6881d51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append_path_info</b> (Src &amp;src, std::string &amp;ret)</td></tr>
<tr class="separator:ad6ed947b141d970bb7ff5c21a6881d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc31d7bab5faf3ee82e73854ff798b7"><td class="memItemLeft" align="right" valign="top"><a id="a0fc31d7bab5faf3ee82e73854ff798b7"></a>
result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stat_from_symlink</b> (struct stat &amp;s, const <a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> &amp;h) noexcept</td></tr>
<tr class="separator:a0fc31d7bab5faf3ee82e73854ff798b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Obtain a handle to the path <b>currently</b> containing this handle's file entry. </p>
<p>Returns an implementation defined string describing the algorithms either to be chosen during connection, or if after connection the algorithms chosen. Can be an empty string if the implementation currently has no mechanism for determining the algorithms available or in use (if the latter you may wish to retry later).</p>
<dl class="section warning"><dt>Warning</dt><dd>This call is <b>racy</b> and can result in the wrong path handle being returned. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory, then checks if the file entry within has the same inode as the open file handle. It will retry this matching until success until the deadline given.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n Calls current_path() and thus is both expensive and calls malloc many times.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>algorithm::cached_parent_handle_adapter&lt;T&gt;</code> which overrides this with a zero cost implementation, thus making unlinking and relinking very considerably quicker.</dd></dl>
<p>Relinks the current path of this open handle to the new path specified. If <code>atomic_replace</code> is true, the relink <b>atomically</b> and silently replaces any item at the new path specified. This operation is both atomic and matching POSIX behaviour even on Microsoft Windows where no Win32 API can match POSIX semantics.</p>
<p>Note that if <code>atomic_replace</code> is false, the operation <em>may</em> be implemented as creating a hard link to the destination (which fails if the destination exists), opening a new file descriptor to the destination, closing the existing file descriptor, replacing the existing file descriptor with the new one (this is to ensure path tracking continues to work), then unlinking the previous link. Thus <code>native_handle()</code>'s value <em>may</em> change. This is not the case on Microsoft Windows nor Linux, both of which provide syscalls capable of refusing to rename if the destination exists.</p>
<p>If the handle refers to a pipe, on Microsoft Windows the base path handle is ignored as there is a single global named pipe namespace. Unless the path fragment begins with <code>\</code>, the string <code>\??\</code> is prefixed to the name before passing it to the NT kernel API which performs the rename. This is because <code>\\.\</code> in Win32 maps onto <code>\??\</code> in the NT kernel.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for renaming an open handle (Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong file entry being relinked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory first, then checks before relinking that the item about to be relinked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base for any relative path. </td></tr>
    <tr><td class="paramname">path</td><td>The relative or absolute new path to relink to. </td></tr>
    <tr><td class="paramname">atomic_replace</td><td>Atomically replace the destination if a file entry already is present there. Choosing false for this will fail if a file entry is already present at the destination, and may not be an atomic operation on some platforms (i.e. both the old and new names may be linked to the same inode for a very short period of time). Windows and recent Linuxes are always atomic. </td></tr>
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for renaming open handles (Windows), calls</dt><dd><code>current_path()</code> via <code>parent_path_handle()</code> and thus is both expensive and calls malloc many times.</dd></dl>
<p>Links the inode referred to by this open handle to the path specified. The current path of this open handle is not changed, unless it has no current path due to being unlinked.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for linking an open handle to a new location (Linux, Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong inode being linked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory first, then checks before linking that the item about to be hard linked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base for any relative path. </td></tr>
    <tr><td class="paramname">path</td><td>The relative or absolute new path to hard link to. </td></tr>
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for renaming open handles (Windows), calls</dt><dd><code>current_path()</code> via <code>parent_path_handle()</code> and thus is both expensive and calls malloc many times.</dd></dl>
<p>Unlinks the current path of this open handle, causing its entry to immediately disappear from the filing system.</p>
<p>On Windows before Windows 10 1709 unless <code>flag::win_disable_unlink_emulation</code> is set, this behaviour is simulated by renaming the file to something random and setting its delete-on-last-close flag. Note that Windows may prevent the renaming of a file in use by another process, if so it will NOT be renamed. After the next handle to that file closes, it will become permanently unopenable by anyone else until the last handle is closed, whereupon the entry will be eventually removed by the operating system.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for unlinking an open handle (Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong file entry being unlinked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the containing directory first, then checks that the item about to be unlinked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for unlinking open handles (Windows), calls</dt><dd><code>current_path()</code> and thus is both expensive and calls malloc many times. On Windows, also calls <code>current_path()</code> if <code>flag::disable_safety_unlinks</code> is not set.</dd></dl>
<p>Fill the supplied buffer with the names of all extended attributes set on this file or directory, returning a span of path view components.</p>
<p>Note that this routine is a very thin wrap of <code>listxattr()</code> on POSIX and <code>NtQueryInformationFile()</code> on Windows. If the supplied buffer is too small, the syscall typically returns failure rather than do a partial fill. Most implementations do not support more than 64Kb of extended attribute information per inode so maybe 70Kb is a safe default (to account for the return value storage), however properly written code will detect the buffer being too small and will auto-expand it until success.</p>
<dl class="section note"><dt>Note</dt><dd>On Windows, this is the list of alternate streams on a file, NOT NTFS extended attributes.</dd></dl>
<p>\raceguarantees The list of extended attributes is fetched in a single syscall. This may be an atomically consistent snapshot.</p>
<p>Retrieve the value of an extended attribute set on this file or directory.</p>
<dl class="section note"><dt>Note</dt><dd>On Windows, this is the list of alternate streams on a file, NOT NTFS extended attributes.</dd></dl>
<p>Sets the value of an extended attribute on this file or directory.</p>
<p>To prevent collision in a globally visible resource, there is a convention whereby you ought to namespace the names of your values as <code>namespace.attribute</code> e.g. <code>appname.setting</code> to prevent unintentional collision with other programs. Obviously, do choose a unique <code>appname</code> if there is any chance another program might use the same namespace name.</p>
<p>On POSIX, there are additional namespacing requirements: before your value name, you need to prefix one of <code>user</code> or <code>system</code>, so the actual name you might set would be <code>user.appname.propname</code>. Windows does not have the <code>user</code>/<code>system</code> prefix requirement, but it does no harm to do the exact same on Windows as on POSIX.</p>
<p>The host OS and target filing system choose the limits on value size, and will fail accordingly. Some impose a maximum of 64Kb for all names and values per inode, others have a 4Kb maximum value size, there are lots of combinations. You are probably safest not setting many names, and keep the values short.</p>
<dl class="section warning"><dt>Warning</dt><dd>Extended attributes are 'brittle' because they can get silently wiped at any moment. Never store anything in extended attributes which cannot be recalculated if missing. The ideal use case for extended attributes is as a cache of additional metadata about a file or directory e.g. "I last checked this directory at timestamp X", or "the MD5 hash at last modified
timestamp X for this file was Y". Also remember that other processes can and do arbitrarily modify extended attributes concurrent to you.</dd></dl>
<h3><a class="anchor" id="autotoc_md8"></a>
Windows only</h3>
<p>This API is implemented as file alternate data streams, rather than the Extended Attributes API as accessed via <code>NtSetEaFile()</code> and <code>NtQueryEaFile()</code> (which actually modify the file alternate data stream <code>$EA</code> in any case).</p>
<p>The reason why is that <code>NtSetEaFile()</code> can only <b>append</b> new records to EA storage. It cannot deallocate any existing EA records, if you try to do so you will get <code>STATUS_EA_CORRUPT_ERROR</code>. You can append setting the same name to a different value, which can include a null value which then appears as if the name is no longer there. But there is a cap of 64kB for the EA record, and once it is consumed, it is gone forever for that inode.</p>
<p>Obviously that doesn't map at all well onto POSIX extended attributes, where you can set the value of an attribute as frequently as you like. The closest equivalent on Windows is therefore file alternate data streams, even though the attribute's value is then worked with as a whole proper file with all the attendant performance consequences.</p>
<p>As a result, <code>name</code> must be a valid filename and not contain any characters not permitted in a filename. We use the NT API here, so the character restrictions are far fewer than for the Win32 API e.g. single character names do NOT cause misoperation like on Win32.</p>
<p>Removes the extended attribute set on this file or directory.</p>
<dl class="section note"><dt>Note</dt><dd>On Windows, this is the list of alternate streams on a file, NOT NTFS extended attributes. We do not prevent you trying to remove internal alternate streams, either.</dd></dl>
<p>Copies the extended attributes from one entity to another, optionally replacing all the extended attributes on the destination.</p>
<p>This convenience function is implemented using the APIs above, and therefore is racy with respect to concurrent users. If you specifiy an invalid source with <code>replace_all_local_attributes = true</code>, then this is a convenient way to remove all extended attributes on the local inode.</p>
<dl class="section note"><dt>Note</dt><dd>This function uses 130Kb of stack and cannot handle attribute values larger than 64Kb.</dd></dl>
<p>Sets the chunk size for registered buffer allocation.</p>
<p>Some TLS socket handle implementations are able to use registered buffers from their underlying plain socket. If so, this sets the granularity of registered buffer allocation, otherwise an error is returned if registered buffers are not supported.</p>
<p>Sets the algorithms to be used by the TLS connection.</p>
<p>Sets the CA certificates by which this connecting socket identifies itself to servers. Defaults to <b>empty</b> i.e. clients do not authenticate themselves to servers.</p>
<p>Note that setting this to an empty path <b>disables</b> authentication by the client, so client impersonation attacks become possible. This can be useful however for situations where setting up client authentication certificates is non-trivial or unnecessary (e.g. a HTTPS client connecting to a HTTPS web service), and all that is wanted is an encrypted network transport.</p>
<p>Be aware that the path may not be a filesystem path, but some other sort of implementation defined identifier.</p>
<p>Sets the name of the server which will be connected to for TLS. </p><dl class="section return"><dt>Returns</dt><dd>The port rendered into a string. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The hostname to connect to. The TLS connection will use this hostname. </td></tr>
    <tr><td class="paramname">port</td><td>The port to connect to. The TLS connection will use this port.</td></tr>
  </table>
  </dd>
</dl>
<p>TLS requires the hostname and port to which it will connect for identity verification. This can be different to the actual IP address to which you connect, if you wish.</p>
<p>If you don't call this before <code>connect()</code> (or don't use the <code>connect()</code> overload also taking <code>host</code> and <code>port</code>), then the client will NOT authenticate the server's certificate.</p>
<p>Connects to a host, setting the TLS connetion hostname. Convenience overload. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The hostname to connect to. The TLS connection will use this hostname. </td></tr>
    <tr><td class="paramname">port</td><td>The port to connect to. The TLS connection will use this port. </td></tr>
    <tr><td class="paramname">d</td><td>How long to wait for a connection.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a convenience overload combining <code>set_connect_hostname()</code> and <code>connect()</code> from the base class.</p>
<p>A coroutinised equivalent to <code>.connect()</code> which suspends the coroutine until a connection occurs. <b>Blocks execution</b> i.e is equivalent to <code>.connect()</code> if no i/o multiplexer has been set on this handle!</p>
<p>The awaitable returned is <b>eager</b> i.e. it immediately begins the i/o. If the i/o completes and finishes immediately, no coroutine suspension occurs. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacellfio__v2__xxx.html">llfio_v2_xxx</a></li><li class="navelem"><a class="el" href="namespacellfio__v2__xxx_1_1detail.html">detail</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
